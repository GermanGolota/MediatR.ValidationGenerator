using MediatR.ValidationGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace MediatR.ValidationGenerator
{
    public record TypeScanResult(ITypeSymbol Type, bool ImplementsIRequest);

    [Generator(LanguageNames.CSharp)]
    public class ValidatorsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("Validator.cs", StaticSourceCodes.Validator);
                ctx.AddSource("ValidationBehavior.cs", StaticSourceCodes.Behavior);
                ctx.AddSource("DIExtensions.cs", StaticSourceCodes.DIExtensions);
            });

            var typeDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider<TypeScanResult>(
                    static (s, _) => s is ClassDeclarationSyntax,
                    static (ctx, _) =>
                    {
                        var info = ctx.SemanticModel.GetTypeInfo(ctx.Node);
                        var type = info.Type;
                        TypeScanResult? result;
                        if (type is not null)
                        {
                            result = new(type, IsImplementing(type));
                        }
                        else
                        {
                            result = null;
                        }

                        return result;
                    })
                .Where(x => x is not null && x.ImplementsIRequest)
                .Select((scanResult, _) => GetValidationModel(scanResult))
                .Where(x => x is not null)
                .Select((x, _) => (x!));

            var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

            context.RegisterSourceOutput(compilationAndTypes,
                static (spc, source) => Execute(source.Left, source.Right, spc));
            throw new NotImplementedException();
        }
        private static RequestValidationModel? GetValidationModel(TypeScanResult scanResult)
        {
            var type = scanResult!.Type;
            RequestValidationModel? result;
            if (type is not null)
            {
                var props = type.GetMembers().OfType<IPropertySymbol>();
                if (props is not null)
                {
                    var requestModel = new RequestValidationModel(type);
                    foreach (var prop in props)
                    {
                        var attributes = prop.GetAttributes();
                        requestModel.PropertyToSupportedAttributes.Add(prop, attributes);
                    }
                    result = requestModel;
                }
                else
                {
                    result = null;
                }
            }
            else
            {
                result = null;
            }
            return result;
        }

        private static string IREQUEST_INTERFACE_NAME = "IBaseRequest";
        private static string IREQUEST_INTERFACE_NAMESPACE = "MediatR";
        private static bool IsImplementing(ITypeSymbol type)
        {
            bool isImplementing = false;
            foreach (var interfaceType in type.AllInterfaces)
            {
                if (interfaceType.Name == IREQUEST_INTERFACE_NAME
                    && interfaceType.ContainingNamespace.Name == IREQUEST_INTERFACE_NAMESPACE)
                {
                    isImplementing = true;
                    break;
                }
            }
            return isImplementing;
        }
        private static void Execute(Compilation compilation,
            ImmutableArray<RequestValidationModel> validationModels,
            SourceProductionContext spc)
        {
            List<Diagnostic> errors = new List<Diagnostic>();
            foreach (var validationModel in validationModels)
            {
                var creationResult = RequestValidatorCreator.CreateValidatorFor(validationModel);
                if (creationResult.HasValue)
                {
                    string source = PrefixAsAutogenerated(creationResult.Value);
                    spc.AddSource(validationModel.ValidatorName, source);
                }
                else
                {
                    Diagnostic error = CreateDiagnostic(validationModel, creationResult);
                    errors.Add(error);
                }
            }
            foreach (var error in errors)
            {
                spc.ReportDiagnostic(error);
            }
        }

        private static Diagnostic CreateDiagnostic(RequestValidationModel validationModel, ValueOrNull<string> creationResult)
        {
            var request = validationModel.RequestClass;
            var location = request.Locations.FirstOrDefault();
            var error = Diagnostic.Create(DiagnosticDescriptors.FailedToCreateValidatorDescriptor, location, request.MetadataName, creationResult.NullMessage);
            return error;
        }

        private static string PrefixAsAutogenerated(string source)
        {
            StringBuilder sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated/>");
            sourceBuilder.AppendLine();
            sourceBuilder.Append(source);
            return sourceBuilder.ToString();
        }
    }
}
